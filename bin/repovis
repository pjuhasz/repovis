#!/usr/bin/perl

# TODO:
# - documentation
# -- nice animgif for peasant blinding
# + track extent of graph (done in extent.pl)
# + outline of file blobs in blame mode (done in extent.pl)
# -- directories?
# + write binary matrices instead of one long line of data per source line
# -- png directly?
# + support for different curves as a startup option
# + revision, exclude, include as options
# - modes:
# ++ analyze that produces blame and file mode data for all revisions, cache it in .repovis
# +++ keep some of the file, user etc. data between revisions for performance and consistency
# +++ use hg stat --change REV to get changed/added/deleted files, and hg blame --rev REV only those files, keep track of the rest
# --- but this mode is broken because of branches
# -- interactive mode that just launches the gnuplot with the cached data (default when ran without parameters)
# -- non-interactive parametric mode to generate image for just one rev
# -- animate to create animations from images
# - commit timeline with the same user/hue, commit/saturation colors as blame mode
# -- branch graph?
# - show deletions by red lines between pixels?
# + file mode colors should vary value, not just saturation
# -- value could show line position (lighter towards end of file)?
# - blame colors: does max saturation mean currently viewed rev, or max rev in repo?
#   - current: then we should change the colors on the timeline too, which is tricky and confusing
#     - timeline colors could be solid with max hue, but then we need a saturation legend on the blame plot itself
#   - max rev: then blame graphs for early revs would be nearly white with no contrast
# - sort files by date?
# + cmdserver for hg (should be as fast or faster than a single blame -unf on all files)
# ++ or just simply return an aref of lines
# + refactor all those max_x etc. calculations into an extent class or something
# - git, svn? support
# ? js+html output? (yuck)

use 5.010001;
use strict;
use warnings;

use Getopt::Long qw/:config no_ignore_case bundling/;
use Pod::Usage;

use VCS::Visualize;

my %options = (
	'analyze-all' => 0,
	'Animate'     => 0,
	'revision'    => undef,
	'include'     => undef,
	'exclude'     => undef,
	'curve'       => 'KochelCurve',
	'cache-dir'   => undef,
	'format'      => undef,
	'output'      => undef,
	'verbose'     => 0,
);

GetOptions(\%options,
	'analyze-all|a!',
	'Animate|A!',
	'revision|r=s@',
	'include|I=s@',
	'exclude|X=s@',
	'curve|c=s',
	'cache-dir=s',
	'format|f=s',
	'output|o=s',
	'verbose|v+',
) or pod2usage(2);
pod2usage(1) if $options{help};

$| = 1 if $options{verbose};

# The remaining cmd line arguments are interpreted as target directories
$ARGV[0] //= '.';
my @dirs = @ARGV;

# init main visualizer ojject
my $vis = VCS::Visualize->new(
	dirs         => [@dirs],
	include      => $options{include},
	exclude      => $options{exclude},
	curve_module => $options{curve},
	verbose      => $options{verbose},
);

# if no revision was specified, assume the current revision
my $revisions = $options{revision} // [ undef ];

# however, in analyze mode, analyze all revisions
if ($options{'analyze-all'}) {
	$vis->analyze_all();
}
else {
	for my $rev (@$revisions) {
		$vis->analyze_one_rev($rev);
	}
}

if ($options{Animate}) {
# TODO create animgif or something
}
elsif (defined $options{format}) {
# TODO  create file	
}
else {
# TODO launch gnuplot interactively
}
